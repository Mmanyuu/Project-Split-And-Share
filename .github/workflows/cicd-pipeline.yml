##two types of commands for gitaction: run(used to execute commands or scripts directly on the runner. such as npm install for installing dependencies) or uses (running usable actions from github marketplace or predefined actions provided by github)

name: CI/CD Pipeline #Heroku deploy

on:
  push:
    branches:
      - develop               # Triggers. Gitaction will trigger when i git push develop branch
      - release               # Triggers. Gitaction will trigger when i git push release branch

jobs:
  
  build:
    runs-on: ${{ matrix.os }} #ensuring our projects can be build on all three kind of OS
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    steps:
      - uses: actions/checkout@v4 #checks out github repo so that any files in my repo, such as dockerfile or configuration files are accessible
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven #Enables Maven dependency caching to speed up builds by reusing previously downloaded dependencies
      - name: Install Dependencies (Maven)
        run: mvn -B clean install -DskipTests # -B for batch mode in mvn command. prevents interactive prompts in Maven, which can cause workflow to hang.
      - name: Upload Artifacts (if needed) #crucial for multi OS build - saving the build outputs (JARs, etc) so that subsequents jobs (like testing and deploy) can use
        if: always() # Always run this step, even if previous steps such as installing dependencies fail. to ensure whatever been build are kept and uploaded
        uses: actions/upload-artifact@v4
        with:
          name: target-${{ matrix.os }} # creating distinct artifact names (e.g. target-ubuntu-latest, target-marcos-latest). prevent overwriting artifacts
          path: target/*.jar # Specifies the location of the .jar files (build artifacts)
          retention-days: 1 # How long to keep the artifacts

  dependencies_scan:
    runs-on: ubuntu-latest # No point scanning all three os cause this is about scanning our project
    needs: build
    if: github.ref_name == 'release' # Only run on release branch
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Install Snyk CLI
        uses: snyk/actions/setup@master #installing the latest version of snyk from github market
      - name: Run Snyk Vulnerability Scan (Dependencies Only)
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }} # Use GitHub secrets
        run: snyk test --file=pom.xml --severity-threshold=high || echo "Issues detected but not failing the build"  # Scan pom.xml for dependencies

  code_scan:
    runs-on: ubuntu-latest # Similar to dependencies test - No point scanning all three os cause this is about scanning our project codes.
    needs: build
    if: github.ref_name == 'release' # Only run on release branch
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Install Snyk CLI
        run: npm install -g snyk # trying to see if can install snyk using npm. this is another way of installing snyk.
      - name: Run Snyk Code Vulnerability Scan
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        run: snyk code test --severity-threshold=medium

  test-develop:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest] #windows fails this test. need to look into this
    needs: build #requires build only for develop branch
    if: github.ref_name == 'develop' # Only run on develop branch
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Download Artifacts #downloading the artifacts that was saved in build
        uses: actions/download-artifact@v4
        with:
          name: target-${{ matrix.os }} #taking respective os target file uploaded as artifact (e.g. target-ubuntu-latest, target-marcos-latest)
          path: target # Download the contents into the 'target' directory
      - name: Run Three Tests
        run: |
          export TEST_CLASSES="sg.edu.ntu.split_and_share.service.UserServiceImplTest,sg.edu.ntu.split_and_share.service.ExpenseServiceImplTest,sg.edu.ntu.split_and_share.controller.ExpenseControllerTest"
          mvn test -Dtest="$TEST_CLASSES"
  
  test-release:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    needs: code_scan # Different from test-develop. this will requires code_scan to pass.
    steps:
      - uses: actions/checkout@v4
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven
      - name: Download Artifacts
        uses: actions/download-artifact@v4
        with:
          name: target-${{ matrix.os }}
          path: target
      - name: Run Three Tests
        run: |
          export TEST_CLASSES="sg.edu.ntu.split_and_share.service.UserServiceImplTest,sg.edu.ntu.split_and_share.service.ExpenseServiceImplTest,sg.edu.ntu.split_and_share.controller.ExpenseControllerTest"
          mvn test -Dtest="$TEST_CLASSES"
  
  build-docker-image:
    runs-on: ubuntu-latest #building image in ubuntu os cause OS doesnt affect the result of container image as the image itself define its runtime environment. Just like we push create our own image in our own laptop and push up to our own dockerhub. other people can still pull and use it.
    needs: test-release #workflow is after test-release passed.
    if: github.ref_name == 'release' # Only run on release branch
    steps:
      - uses: actions/checkout@v4
      - name: Login to Docker Hub
        run: echo ${{ secrets.DOCKERHUB_PASSWORD }} | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin
      - name: Pull Docker Image
        run: docker pull bindugopinathan/project_split_and_share:tagname
      - name: Tag Docker Image #changing tag
        run: docker tag bindugopinathan/project_split_and_share:tagname bindugopinathan/project_split_and_share:${{ github.sha }} #git.sha is dynamically generated tags
      - name: Push Docker Image
        run: docker push bindugopinathan/project_split_and_share:${{ github.sha }}
  
  deploy:
    runs-on: ubuntu-latest # runs on just one os cause deploying separate build (one for each os) to the same app will overwrite the existing deployment multiple times and may cause unintended results
    needs: build-docker-image
    if: github.ref_name == 'release' # Only run on release branch
    steps:
      - uses: actions/checkout@v4
      - name: Install Heroku CLI #another way i found out is to use ---> uses: akhileshns/heroku-deploy@v3.13.15 (which requires email, appname and apikey saved as secrets)
        run: curl https://cli-assets.heroku.com/install-ubuntu.sh | sh #installs the Heroku CLI (Command Line Interface) on the runner
      - name: Docker Login to Heroku #necessary cause interacting with Docker's registry (Herokuâ€™s private registry in this case). need to authenticate Docker to make sure you're authorized to push images to Heroku
        run: echo ${{ secrets.HEROKU_API_KEY }} | docker login --username=_ --password-stdin registry.heroku.com #secrets in gitaction need to put secrets.<nameofsecret>
      - name: Push and Release to Heroku
        run: |
          heroku container:push web -a bindu-split-and-share
          heroku container:release web -a bindu-split-and-share